# HealthCare dApp

A decentralized application (dApp) built with Next.js and Solidity for managing healthcare-related functionalities on the blockchain.

## Features

Based on the project structure (`Components/` directory), potential features include:

- **Admin Dashboard:** Management interface for administrators.
  - Medicine Management (Add/Update)
  - Appointment Overview
  - User Management (AppUser, Doctor, Patient)
  - Admin Profile Management
- **User Authentication:** Secure login and registration for different user roles.
- **Appointment Scheduling:** Booking and managing appointments with doctors.
- **Profiles:** Detailed profiles for Patients, Doctors, and Staff.
- **Medical History:** Tracking patient medical records securely (potentially on-chain).
- **Prescriptions:** Managing and viewing prescriptions.
- **AI Integration:** Features leveraging AI capabilities (details depend on implementation in `Components/Global/AI`).
- **Chat Functionality:** Real-time communication features.
- **Medicine Shop/Orders:** Browsing and ordering medicines.
- **Notifications:** In-app notifications system.
- **Blockchain Interaction:** Leveraging blockchain for data integrity, transparency, or specific workflows (e.g., using the `Medical.sol` contract).

## Tech Stack

- **Frontend:**
  - Next.js (v13.4.13)
  - React (v18.2.0)
  - Ethers.js (v5.7.2)
  - Web3Modal
  - Axios
  - React Icons, React Hot Toast, React Dropzone
  - Google Generative AI SDK
  - CSS/SCSS (Structure suggests usage in `public/css`, `public/scss`)
- **Blockchain:**
  - Solidity (v0.8.17)
  - Hardhat (v2.12.0)
  - Hyperledger Besu (Private Network with QBFT consensus)
  - Ethereum Virtual Machine (EVM)
- **Development Tools:**
  - Node.js
  - npm/yarn
  - Docker (likely required for running the Besu QBFT network and Monitoring stack)
- **Monitoring:**
  - Prometheus
  - Grafana (with custom dashboard defined in `dashboard.json`)

## Project Structure

```
├── Components/         # React components organized by feature/scope
├── Context/            # React context providers for state management
├── contracts/          # Solidity smart contracts (e.g., Medical.sol)
├── pages/              # Next.js pages and API routes
├── public/             # Static assets (images, css, js vendor libs)
├── scripts/            # Deployment or utility scripts (likely for Hardhat)
├── styles/             # Global styles or SCSS partials
├── QBFT-Network/       # Configuration/data for a local QBFT Besu network setup
├── artifacts/          # Compiled contract artifacts (generated by Hardhat)
├── cache/              # Hardhat cache
├── prometheus-config.yml # Prometheus configuration
├── dashboard.json      # Grafana dashboard configuration
├── .env.local          # Local environment variables (GITIGNORED)
├── .env.sample         # Sample environment variables file
├── hardhat.config.js   # Hardhat configuration
├── next.config.js      # Next.js configuration
├── package.json        # Project dependencies and scripts
└── README.md           # This file
```

## Architecture Diagram

```mermaid
graph TD
    subgraph "User Interface"
        A["User Browser (Patient/Doctor/Admin)"] --> B{Next.js Frontend};
    end

    subgraph "Application Logic"
        B --> C[Next.js API Routes / Server-Side Logic];
        B --> D[React Components & Context];
        C --> E{"External APIs (e.g., Google AI)"};
    end

    subgraph "Blockchain Network (Hyperledger Besu + QBFT)"
        N1[Besu Node 1] --> N2[Besu Node 2];
        N2 --> N3[Besu Node 3];
        N3 --> N4[Besu Node 4];
        N4 --> N1;
        N1 --- F[Medical.sol Smart Contract];
        N2 --- F;
        N3 --- F;
        N4 --- F;
    end

    subgraph "Blockchain Interaction"
      G[Web3Modal / Ethers.js]
    end

    subgraph "Monitoring Stack"
        P[Prometheus] --> GR[Grafana];
        N1 -- Metrics --> P;
        N2 -- Metrics --> P;
        N3 -- Metrics --> P;
        N4 -- Metrics --> P;
    end

    B -- Blockchain Reads/Writes --> G;
    G -- JSON-RPC Calls --> N1;
    C -- Optional Backend Interaction --> N1;

    style F fill:#f9f,stroke:#333,stroke-width:2px,color:#000
    style N1 fill:#ccf,stroke:#333,stroke-width:1px,color:#000
    style N2 fill:#ccf,stroke:#333,stroke-width:1px,color:#000
    style N3 fill:#ccf,stroke:#333,stroke-width:1px,color:#000
    style N4 fill:#ccf,stroke:#333,stroke-width:1px,color:#000
    style P fill:#fcc,stroke:#333,stroke-width:1px,color:#000
    style GR fill:#cfc,stroke:#333,stroke-width:1px,color:#000
```

## QBFT Consensus Flow (Simplified)

This diagram shows a simplified view of the message exchange between validator nodes during a QBFT consensus round to agree on a new block.

```mermaid
sequenceDiagram
    participant Proposer
    participant Validator A
    participant Validator B
    participant Validator C

    Proposer->>+Validator A: Propose Block (PrePrepare)
    Proposer->>+Validator B: Propose Block (PrePrepare)
    Proposer->>+Validator C: Propose Block (PrePrepare)

    Validator A->>+Proposer: Prepare
    Validator A->>+Validator B: Prepare
    Validator A->>+Validator C: Prepare

    Validator B->>+Proposer: Prepare
    Validator B->>+Validator A: Prepare
    Validator B->>+Validator C: Prepare

    Validator C->>+Proposer: Prepare
    Validator C->>+Validator A: Prepare
    Validator C->>+Validator B: Prepare

    Note over Proposer, Validator C: Validators collect 2F+1 Prepare messages

    Validator A->>+Proposer: Commit
    Validator A->>+Validator B: Commit
    Validator A->>+Validator C: Commit

    Validator B->>+Proposer: Commit
    Validator B->>+Validator A: Commit
    Validator B->>+Validator C: Commit

    Validator C->>+Proposer: Commit
    Validator C->>+Validator A: Commit
    Validator C->>+Validator B: Commit

    Note over Proposer, Validator C: Validators collect 2F+1 Commit messages & agree on block
```

## Example Application Flow (Appointment Booking)

This diagram illustrates the sequence of interactions when a user books an appointment.

```mermaid
sequenceDiagram
    participant User
    participant Browser (Next.js Frontend)
    participant Wallet (MetaMask)
    participant Besu Node (JSON-RPC)
    participant Medical Contract

    User->>Browser: <font color="white">Selects Doctor & Time Slot</font>
    Browser->>User: <font color="white">Displays Appointment Details & Confirmation</font>
    User->>Browser: <font color="white">Confirms Booking</font>
    Browser->>Wallet: <font color="white">Initiate `bookAppointment` Transaction</font>
    Wallet->>User: <font color="white">Request Transaction Signature</font>
    User->>Wallet: <font color="white">Approves Transaction</font>
    Wallet->>Besu Node: <font color="white">Send Signed Transaction</font>
    Besu Node->>Medical Contract: <font color="white">Execute `bookAppointment` Function</font>
    Medical Contract-->>Besu Node: <font color="white">Transaction Receipt (Success/Fail)</font>
    Besu Node-->>Wallet: <font color="white">Transaction Confirmed</font>
    Wallet-->>Browser: <font color="white">Transaction Confirmation</font>
    Browser->>User: <font color="white">Show Success Message / Update UI</font>
```

## Frontend Component Interaction

This diagram shows potential interactions between major UI components, context, and backend/blockchain services.

```mermaid
graph TD
    subgraph "Browser UI Components"
        Comp_Profile["Profile (Patient/Doctor)"]
        Comp_Appt[Appointment Scheduling]
        Comp_MedHist[Medical History]
        Comp_Presc[Prescription View]
        Comp_Shop[Medicine Shop]
        Comp_Chat[Chat]
        Comp_Admin[Admin Dashboard]
    end

    subgraph "State Management"
        Ctx["React Context (e.g., User Info, Contract Data)"]
    end

    subgraph "Backend / Blockchain"
        API["Next.js API Routes (Optional)"]
        AI_API{"External AI Service"}
        Wallet["Wallet Interaction (Ethers/Web3Modal)"]
        Contract[Medical.sol Contract]
    end

    Comp_Profile --> Ctx
    Comp_Appt --> Ctx
    Comp_MedHist --> Ctx
    Comp_Presc --> Ctx
    Comp_Shop --> Ctx
    Comp_Chat --> Ctx
    Comp_Admin --> Ctx

    Ctx --> Wallet
    Wallet --> Contract

    Comp_Profile -- Reads data --> Ctx
    Comp_Appt -- Reads/Writes data --> Ctx
    Comp_MedHist -- Reads data --> Ctx
    Comp_Presc -- Reads data --> Ctx
    Comp_Admin -- Reads/Writes data --> Ctx

    Comp_Shop -- May use --> API
    Comp_Chat -- May use --> API
    API -- Optional --> Wallet
    API -- Optional --> AI_API

    Comp_Admin -- Admin actions --> Wallet
    Comp_Appt -- Booking actions --> Wallet

    %% Explicit calls if context doesn't abstract everything
    Comp_MedHist -- Direct Read? --> Wallet
    Comp_Presc -- Direct Read? --> Wallet
```

## Detailed Data Flow (Example: Prescription Creation)

Illustrates how a prescription might be created and stored.

```mermaid
sequenceDiagram
    participant Doctor
    participant Browser (Frontend UI)
    participant Wallet (MetaMask)
    participant Besu Node
    participant Medical Contract
    participant Patient

    Doctor->>+Browser: Logs in, Navigates to Create Prescription
    Browser->>+Doctor: Shows Prescription Form
    Doctor->>+Browser: Fills in Patient ID, Medication, Dosage, etc.
    Browser->>+Doctor: Ready to Submit
    Doctor->>+Browser: Clicks "Submit Prescription"
    Browser->>+Wallet: Initiate `createPrescription` Transaction (with data)
    Wallet->>+Doctor: Request Transaction Signature
    Doctor->>+Wallet: Approves Transaction
    Wallet->>+Besu Node: Send Signed Transaction
    Besu Node->>+Medical Contract: Execute `createPrescription(patientId, details)`
    Medical Contract-->>-Besu Node: Stores Prescription data (event emitted?)
    Besu Node-->>-Wallet: Transaction Confirmed
    Wallet-->>-Browser: Confirmation Received
    Browser->>-Doctor: Success Message

    Note right of Medical Contract: Prescription details potentially stored on-chain or hash stored on-chain with details off-chain.

    Patient->>+Browser: Logs in, Navigates to View Prescriptions
    Browser->>+Wallet: Request `getPatientPrescriptions(patientId)`
    Wallet->>+Besu Node: Send Call Request
    Besu Node->>+Medical Contract: Execute `getPatientPrescriptions(patientId)` (read function)
    Medical Contract-->>-Besu Node: Returns Prescription Data/IDs
    Besu Node-->>-Wallet: Prescription Data Received
    Wallet-->>-Browser: Data Forwarded
    Browser->>-Patient: Displays Prescriptions
```

## Deployment Architecture

Shows the likely runtime deployment setup.

```mermaid
graph TD
    subgraph "User Access"
        User["User's Browser"] --> LB[Load Balancer / CDN?];
    end

    subgraph "Hosting Environment (e.g., Docker)"
        LB --> AppServer[Next.js App Server];

        subgraph "Besu QBFT Network"
            direction LR
            Node1["Besu Node 1 (Validator)"]
            Node2["Besu Node 2 (Validator)"]
            Node3["Besu Node 3 (Validator)"]
            Node4["Besu Node 4 (Validator)"]
            Node1 <--> Node2;
            Node1 <--> Node3;
            Node1 <--> Node4;
            Node2 <--> Node3;
            Node2 <--> Node4;
            Node3 <--> Node4;
        end

        subgraph "Monitoring"
            Prom[Prometheus Server]
            Graf[Grafana Server]
        end

        AppServer -- JSON-RPC --> Node1;
        Node1 -- Metrics --> Prom;
        Node2 -- Metrics --> Prom;
        Node3 -- Metrics --> Prom;
        Node4 -- Metrics --> Prom;
        Prom --> Graf[Data Source];
    end

    User -- View Dashboards --> Graf;

    style Node1 fill:#ccf,stroke:#333,color:#000
    style Node2 fill:#ccf,stroke:#333,color:#000
    style Node3 fill:#ccf,stroke:#333,color:#000
    style Node4 fill:#ccf,stroke:#333,color:#000
    style Prom fill:#fcc,stroke:#333,color:#000
    style Graf fill:#cfc,stroke:#333,color:#000
```

## User Roles and Permissions (Conceptual)

Maps user roles to potential application/contract capabilities.

```mermaid
graph LR
    subgraph Roles
        Admin
        Doctor
        Patient
    end

    subgraph Features / Actions
        ManageUsers["Manage Users (Add/Remove Doctor/Patient)"]
        ManageMeds["Manage Medicines (Add/Update)"]
        ViewAllAppts["View All Appointments"]
        CreateAppt["Create/Book Appointment"]
        ViewMyAppts["View My Appointments"]
        CreatePresc["Create Prescription"]
        ViewMyPrescs["View My Prescriptions"]
        ViewMyHistory["View My Medical History"]
        UpdateMyHistory["Update Patient Medical History"]
        ChatFeature["Use Chat"]
    end

    Admin --> ManageUsers
    Admin --> ManageMeds
    Admin --> ViewAllAppts

    Doctor --> ViewMyAppts
    Doctor --> CreatePresc
    Doctor --> UpdateMyHistory
    Doctor --> ChatFeature

    Patient --> CreateAppt
    Patient --> ViewMyAppts
    Patient --> ViewMyPrescs
    Patient --> ViewMyHistory
    Patient --> ChatFeature
```

## Smart Contract State Diagram (Hypothetical Example: Appointment)

**Note:** This is a _hypothetical_ state diagram for an Appointment entity within `Medical.sol`, as the actual implementation is not known.

```mermaid
stateDiagram-v2
    [*] --> Scheduled: bookAppointment()
    Scheduled --> Confirmed: confirmAppointment() [by Doctor/Admin]
    Scheduled --> Cancelled: cancelAppointment() [by Patient/Doctor/Admin]
    Confirmed --> Completed: markComplete() [by Doctor]
    Confirmed --> Cancelled_Confirmed "Cancelled (by Doctor/Admin)": cancelAppointment()
    Cancelled --> [*]
    Cancelled_Confirmed --> [*]
    Completed --> [*]
```

## Detailed Interaction Flow (Doctor Registration & Approval)

This diagram details the sequence for a doctor registering, including payment (hypothetical), admin approval, and the underlying blockchain interactions with QBFT consensus represented.

```mermaid
sequenceDiagram
    participant Doctor
    participant Browser (Frontend UI)
    participant Wallet (MetaMask)
    participant Besu Node
    box rgba(200, 200, 255, 0.2) Besu Network (QBFT Consensus)
        participant Node1 as Besu Node 1
        participant Node2 as Besu Node 2..4
    end
    participant Medical Contract
    participant Admin

    %% --- Registration & Payment Phase ---
    Doctor->>+Browser: Fills Registration Form (Details + Clicks Register)
    Browser->>+Wallet: Initiate Registration Payment Transaction (e.g., call `processRegistrationPayment`)
    Wallet->>+Doctor: Request Payment Approval
    Doctor->>+Wallet: Approves Payment Transaction
    Wallet->>+Besu Node: Send Signed Payment Tx
    activate Besu Node
    Besu Node->>Node1: Propagate Tx
    activate Node1
    Node1->>Node2: QBFT Consensus Rounds (PrePrepare, Prepare, Commit)
    activate Node2
    Node2-->>Node1: Consensus Achieved
    deactivate Node2
    Node1->>Medical Contract: Execute `processRegistrationPayment()`
    activate Medical Contract
    Medical Contract-->>Node1: Payment Recorded (Success)
    deactivate Medical Contract
    Node1-->>Besu Node: Tx Included in Block
    deactivate Node1
    Besu Node-->>-Wallet: Payment Transaction Confirmed
    deactivate Besu Node
    Wallet-->>-Browser: Payment Confirmed

    %% --- Submitting Registration Data Phase ---
    Browser->>+Wallet: Initiate `requestDoctorRegistration` Transaction (with Doctor's details/address)
    Wallet->>+Doctor: Request Transaction Signature for Registration Data
    Doctor->>+Wallet: Approves Transaction
    Wallet->>+Besu Node: Send Signed Registration Request Tx
    activate Besu Node
    Besu Node->>Node1: Propagate Tx
    activate Node1
    Node1->>Node2: QBFT Consensus Rounds
    activate Node2
    Node2-->>Node1: Consensus Achieved
    deactivate Node2
    Node1->>Medical Contract: Execute `requestDoctorRegistration(...)`
    activate Medical Contract
    Medical Contract-->>Node1: Doctor Request Pending (e.g., status updated, event emitted)
    deactivate Medical Contract
    Node1-->>Besu Node: Tx Included in Block
    deactivate Node1
    Besu Node-->>-Wallet: Registration Request Tx Confirmed
    deactivate Besu Node
    Wallet-->>-Browser: Request Confirmed
    Browser->>-Doctor: Show "Registration Submitted, Pending Admin Approval"

    %% --- Admin Approval Phase ---
    Admin->>+Browser: Logs in, Views Pending Doctor Requests
    Browser->>+Wallet: Read Pending Requests (e.g., call `getPendingDoctors`)
    Wallet->>+Besu Node: Send Call Request
    activate Besu Node
    Besu Node->>Medical Contract: Execute `getPendingDoctors()` (read function)
    activate Medical Contract
    Medical Contract-->>Besu Node: Returns List of Pending Doctors
    deactivate Medical Contract
    Besu Node-->>-Wallet: Pending List Received
    deactivate Besu Node
    Wallet-->>-Browser: Data Forwarded
    Browser->>+Admin: Displays Pending Doctors List
    Admin->>+Browser: Selects Doctor, Clicks "Approve"
    Browser->>+Wallet: Initiate `approveDoctor` Transaction (with Doctor's address)
    Wallet->>+Admin: Request Approval Transaction Signature
    Admin->>+Wallet: Approves Transaction
    Wallet->>+Besu Node: Send Signed Approval Tx
    activate Besu Node
    Besu Node->>Node1: Propagate Tx
    activate Node1
    Node1->>Node2: QBFT Consensus Rounds
    activate Node2
    Node2-->>Node1: Consensus Achieved
    deactivate Node2
    Node1->>Medical Contract: Execute `approveDoctor(doctorAddress)`
    activate Medical Contract
    Medical Contract-->>Node1: Doctor Status Updated to 'Approved' (event emitted?)
    deactivate Medical Contract
    Node1-->>Besu Node: Tx Included in Block
    deactivate Node1
    Besu Node-->>-Wallet: Approval Tx Confirmed
    deactivate Besu Node
    Wallet-->>-Browser: Approval Confirmed
    Browser->>-Admin: Show "Doctor Approved Successfully"

    %% --- Doctor Checks Status (Later) ---
    Doctor->>+Browser: Logs in
    Browser->>+Wallet: Read Doctor Status (e.g., call `getDoctorStatus(myAddress)`)
    Wallet->>+Besu Node: Send Call Request
    activate Besu Node
    Besu Node->>Medical Contract: Execute `getDoctorStatus(...)`
    activate Medical Contract
    Medical Contract-->>Besu Node: Returns Status 'Approved'
    deactivate Medical Contract
    Besu Node-->>-Wallet: Status Received
    deactivate Besu Node
    Wallet-->>-Browser: Data Forwarded
    Browser->>-Doctor: Displays Approved Status / Grants Access
```

## Getting Started

### Prerequisites

- Node.js (v16 or later recommended)
- npm or yarn
- Git
- MetaMask browser extension (or other web3 wallet)
- Docker (likely required for running the Besu QBFT network and Monitoring stack)

### Installation & Setup

1.  **Clone the repository:**

    ```bash
    git clone <repository-url>
    cd healthcare-dapp
    ```

2.  **Install dependencies:**

    ```bash
    npm install
    # or
    yarn install
    ```

3.  **Set up environment variables:**

    - Copy the sample environment file:
      ```powershell
      copy .env.sample .env.local
      ```
    - Fill in the required values in `.env.local`. This will likely include:
      - RPC URLs for blockchain networks (e.g., `NEXT_PUBLIC_RPC_URL` if deploying to a testnet/mainnet, or your local Besu RPC)
      - Private keys for deployment (ensure these are kept secure and are intended for development/testing, like `NEXT_PUBLIC_PRIVATE_KEY` seen in `hardhat.config.js`)
      - API keys (e.g., for Google Generative AI)

4.  **Blockchain Setup:**

- **Network & Monitoring:**
  - The primary setup involves running the Hyperledger Besu network configured in the `QBFT-Network/` directory. This setup likely uses Docker Compose or similar tools.
  - Follow the specific instructions for initializing and running the Besu nodes, Prometheus (`prometheus-config.yml`), and Grafana (`dashboard.json`). The `hardhat.config.js` is configured to connect to the Besu network's RPC endpoint (e.g., `http://localhost:8545`).
- **Compile Contracts:**
  ```bash
  npx hardhat compile
  ```
- **Alternative (Simple Testing): Hardhat Network:** For quick contract testing without the full Besu setup, you can use the built-in Hardhat network:
  ```bash
  npx hardhat node
  ```
  _Note: This will not interact with the Besu network or its state._
- **Deploy Contracts:**

  - You'll likely need a deployment script in the `scripts/` directory (e.g., `deploy.js`).
  - Run the deployment script, targeting your chosen network:

    ```bash
    # Example for Hardhat local network (if using for simple testing)
    npx hardhat run scripts/deploy.js --network localhost
    ```

  - After deployment, update your `.env.local` or frontend configuration with the deployed contract address(es).

### Running the Application

1.  **Start the development server:**

    ```bash
    npm run dev
    # or
    yarn dev
    ```

    This will start the Next.js application, typically on `http://localhost:4000` (as specified in `package.json`).

2.  **Open your browser:** Navigate to `http://localhost:4000`.

3.  **Connect Wallet:** Use the application's UI (likely involving Web3Modal) to connect your MetaMask wallet. Ensure MetaMask is connected to the same network where the contracts were deployed (e.g., Localhost 8545 for the Hardhat node or your Besu network).

4.  **(Optional) Access Monitoring:**

- Access Grafana (usually on `http://localhost:3000`) to view the blockchain network dashboard configured via `dashboard.json`.
- Access Prometheus (usually on `http://localhost:9090`) to view raw metrics.

## Scripts

- `npm run dev`: Starts the Next.js development server on port 4000.
- `npm run build`: Builds the Next.js application for production.
- `npm run start`: Starts the production Next.js server (requires `build` first).
- `npm run lint`: Lints the codebase using Next.js's built-in ESLint configuration.
- `npx hardhat compile`: Compiles Solidity contracts.
- `npx hardhat node`: Runs a local Hardhat Ethereum node.
- `npx hardhat test`: Runs contract tests (if any exist in `test/`).
- `npx hardhat run <script>`: Executes a Hardhat script.

## Contributing

(Optional: Add contribution guidelines if this is an open-source project).

## License

(Check `package.json` or add a `LICENSE` file - currently assumes private use based on `package.json`).
